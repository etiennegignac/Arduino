/*//////////////////////////////////////////////////////////////////////////////
Name:  TB_STEP_TEST
CPU:   UNO
Date:  7 Dec 25
Description:  Use this to test moving the TB in steps until it reaches a target

**********  WIRING  **********
ARDUINO:
Pin No      Function        Description
A0          TB_TSP1         Analog read of voltage of throttle position sensor #1 of the throttle body (not the pedal!)

H-BRIDGE:
Pin No      Function        Description
1           RPWM            Forward Level or PWM signal, Active High
2           LPWM            Reverse Level or PWM signal, Active High --> WE DONT USE THIS
3           R_EN            Forward Drive Enable Input, Active High/ Low Disable --> ALWAYS ENABLE
4           L_EN            Reverse Drive Enable Input, Active High/Low Disable --> ALWAYS ENABLE
5           R_IS            Forward Drive, Side current alarm output
6           L_IS            Reverse Drive, Side current alarm output
7           Vcc             +5V Power Supply microcontroller --> Also works on 3.3v according to datasheet, to 3.3V of Teensy
8           Gnd             Ground Power Supply microcontroller --> to ground of Teensy

////////////////////////////////////////////////////////////////////////////////*/

#define FWD 9                 //Output PWM to H-Bridge (motor forward (LPWM in datasheet))
#define REV 10                //Output PWM to H-Bridge (motor reverse (RPWM in datasheet))
#define TB_TPS1 A0            //Analog value of throttle body position sensor #1
#define PWM_HOLD 18           //Value sent to analogWrite() that best holds the TB in a position against the internal return spring
#define PWM_SLOW_OPEN 70      //Use this value to slowly open the TB (for testing purposes)
#define PWM_SLOW_CLOSE 1      //Use this value to slowly close the TB, return spring helps! (for testing purposes)
#define PWM_FAST 255          //Full speed PWM for analogWrite()
#define TB_ERROR 10            //Error range for analogRead
#define MAX_RANDOM_VALUES 500 //Used when IN_TRUCK is false.  Max number of loops through readTarget() before changing random number 

#define IN_TRUCK  0   //variable used by readTarget to differentiate if in the truck (pedal) or developing (random number generator)

int TB_TPS1_Closed = 0;//Analog value when throttle body closed (high number)
int TB_TPS1_Open  = 0;//Analog value when throttle body opened (low number)

int TB_current = 0;   //Value of current TB_TPS1 used to seek target
int TB_target = 0;    //Value of target TB_TPS1

int nb_random_iterations = 0; //Used when IN_TRUCK is false.  Counter of how many loop this many times through readTarget() before changing random number
int random_target = 0;        //Random target generated by readTarget when IN_TRUCK is false.

//One time setup
void setup()
{
  Serial.begin(250000);         //Console for debug

  //Setup pins
  pinMode(FWD, OUTPUT);       //Output high when going increasing throttle body
  pinMode(REV, OUTPUT);       //Output high when decresing or closing throttle body

  //Make sure we are stopped
  //Calibrate here?
  //calibrate();

  analogWrite(FWD, 0);
  analogWrite(REV, 0);
  
  delay(1000); //1 sec delay to let the return spring do its thing and give time to Serial to initialize

  calibrate();

  //Update new random target
  random_target = random(TB_TPS1_Open, TB_TPS1_Closed);
  //Serial.println("Setup completed.");
}

//This function checks the analog value of TB_TPS1 when throttle body is closed and then fully opened
void calibrate()
{
  Serial.print("Before calibration: Closed: ");
  Serial.print(TB_TPS1_Closed);
  Serial.print(" , Open: ");
  Serial.println(TB_TPS1_Open);

  //Close throttle body full speed for a period
  analogWrite(FWD, 0);
  analogWrite(REV, PWM_FAST);
  delay(250);

  //Release to resting position for a period (do nothing, let spring do its thing)
  analogWrite(FWD, 0);
  analogWrite(REV, 0);
  delay(250);

  //Record closed value (high number)
  TB_TPS1_Closed = analogRead(TB_TPS1);
  //Serial.print("Closed: ");
  //Serial.print(TB_TPS1_Closed);

  /*
  delay(2000);
  Serial.print("Re-test: ");
  Serial.println(analogRead(TB_TPS1));
  //*/

  //while(1);
  //delay(1000); //Delay just for cleanliness

  //Open throtthe body full speed for a period
  analogWrite(FWD, PWM_FAST);
  analogWrite(REV, 0);
  delay(250);

  //Hold for a period
  analogWrite(FWD, PWM_HOLD);
  analogWrite(REV, 0);
  delay(250);

  //Record opened value (low number)
  TB_TPS1_Open = analogRead(TB_TPS1);
  //Serial.print(", Open: ");
  //Serial.println(TB_TPS1_Open);


  //DONE, actively close TB
  //Close throttle body full speed for a period
  analogWrite(FWD, 0);
  analogWrite(REV, PWM_FAST);
  delay(250);

  //Release to resting position for a period (do nothing, let spring do its thing)
  analogWrite(FWD, 0);
  analogWrite(REV, 0);
  delay(250);

  Serial.print("After calibration: Closed: ");
  Serial.print(TB_TPS1_Closed);
  Serial.print(" , Open: ");
  Serial.println(TB_TPS1_Open);
}

//This function sets the next analog target for the throttle body to go to.  It can either read the pedal when in the truck or
//giving another number when bench developing.
//Has to be between previously calibrated values
int readTarget()
{

//We are in the truck, read pedal and return
#if IN_TRUCK
  return 0;

//We are on the computer, generate a random number between high and low limits
#else
  if(nb_random_iterations > MAX_RANDOM_VALUES)
  {
    //Reset counter
    nb_random_iterations = 0;

    //Update new random target
    random_target = random(TB_TPS1_Open, TB_TPS1_Closed);
  }
  
  //We are still within the number of loops for this readTarget()
  else
  {
    //Increase counter
    nb_random_iterations++;
  }

  //Return value
  return random_target;

#endif
}



void loop()
{
  while(1);

  //Next target
  //delay(100);

  //Save current TB position
  TB_current = analogRead(TB_TPS1);

  //Get target position
  TB_target = readTarget();

  Serial.print("Target:current --> ");
  Serial.print(TB_target);
  Serial.print(":");
  Serial.println(TB_current);
  
  //If we are more than the error range away, and target is lower than current, open throttle body
  if((abs(TB_target - TB_current) > TB_ERROR) && (TB_target < TB_current))
  {
    Serial.println("OPENING...");
    analogWrite(FWD, PWM_SLOW_OPEN);
    analogWrite(REV, 0);

    //open throttle body until we are within range
    while((abs(TB_target - TB_current) > TB_ERROR) && (TB_target < TB_current))
    {
      Serial.print("Current: ");
      Serial.println(TB_current);
      TB_current = analogRead(TB_TPS1);
      //delay(50);
    }

    //HOLD if we are there (didn't overshoot)
    if((abs(TB_target - TB_current) <= TB_ERROR))
    {
      Serial.println("HOLDING!");
      analogWrite(FWD, PWM_HOLD);
      //analogWrite(REV, 0);
    }
  }

  //Else if we are more than the error range away, and target is higher than current, close throttle body
  if((abs(TB_target - TB_current) > TB_ERROR) && (TB_target > TB_current))
  {
    Serial.println("CLOSING...");
    analogWrite(FWD, 0);
    analogWrite(REV, PWM_SLOW_CLOSE);
    
    //close throttle body until we are within range
    while((abs(TB_target - TB_current) > TB_ERROR) && (TB_target > TB_current))
    {
      Serial.print("Current: ");
      Serial.println(TB_current);
      TB_current = analogRead(TB_TPS1);
      //delay(50);
    }

    //HOLD if we are there (didn't overshoot)
    if((abs(TB_target - TB_current) <= TB_ERROR))
    {
      Serial.println("HOLDING!");
      analogWrite(FWD, PWM_HOLD);
      analogWrite(REV, 0);
    }
  }

  //delay(1000);
  //TB_current = analogRead(TB_TPS1);

/*
  Serial.print("Current: ");
  Serial.print(TB_current);
  Serial.print(" Target: ");
  Serial.println(TB_target);
  */
  //delay(1000);
  //while(1);

  //analogRead is between 0 and 1023
}
